<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link href="coqdoc.css" rel="stylesheet" type="text/css" />
    <link href="coqdocjs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="config.js"></script>
    <script type="text/javascript" src="coqdocjs.js"></script>
    <script type="text/javascript" src="jquery-3.1.0.min.js"></script>
    <script type="text/javascript" src="loadtoc.js"></script>
    <script type="text/javascript">
     function populate() {
       loadToC(function () {
         $("#sectionCocri").append(tocmodules(/Lvc.Spilling.SpillSound/));

         $("#sectionAlgo").append(tocmodules(/Lvc.Spilling.SimpleSpill/));
         $("#sectionAlgo").append(tocmodules(/Lvc.Spilling.SplitSpill/));

         $("#sectionRcnstr").append(tocmodules(/Lvc.Spilling.ReconstrLive/));
         $("#sectionRcnstr").append(tocmodules(/Lvc.Spilling.ReconstrLiveSound/));

         $("#sectionSound").append(tocmodules(/Lvc.Spilling.VarInRegister/));
         $("#sectionSound").append(tocmodules(/Lvc.Spilling.RegisterBound/));
         $("#sectionSound").append(tocmodules(/Lvc.Spilling.SpillSim/));

         $("#sectionSpill").append(tocmodules(/Lvc.Spilling.DoSpill/));
         $("#sectionSpill").append(tocmodules(/Lvc.Spilling.Slot/));

         $("#sectionUtil").append(tocmodules(/Lvc.Spilling.SetUtil/));
         $("#sectionUtil").append(tocmodules(/Lvc.Spilling.SpillUtil/));
         $("#sectionUtil").append(tocmodules(/Lvc.Spilling.Spilling/));
         $("#sectionUtil").append(tocmodules(/Lvc.Spilling.ExpVarsBound/));
         $("#sectionUtil").append(tocmodules(/Lvc.Spilling.InVD/));
         $("#sectionUtil").append(tocmodules(/Lvc.Spilling.BoundedIn/));
         $("#sectionUtil").append(tocmodules(/Lvc.Spilling.AnnP/));
     
         $("#sectionRepair").append(tocmodules(/Lvc.Spilling.RepairSpill$/));
         $("#sectionRepair").append(tocmodules(/Lvc.Spilling.RepairSpillSound/));
         $("#sectionRepair").append(tocmodules(/Lvc.Spilling.RepairSpillIdem/));


         $("#sectionIL").append(tocmodules(/Lvc.Isa.Op/));
         $("#sectionIL").append(tocmodules(/Lvc.IL.Exp/));
         $("#sectionIL").append(tocmodules(/Lvc.IL.IL$/));

         $("#sectionLiveness").append(tocmodules(/Lvc.Liveness.Liveness/));
       });
	  }
    </script>
    <style>
     h3 + div#toc {
       margin-left: 2em;
     }
     .download {
       color:#4078c0;
     }
    </style>
  </head>

  <body onload="populate(); document.getElementById('content').focus()">
    <div id="header">
      <span class="left">
	<span class="modulename"> <script> document.write(document.title) </script> </span>
      </span>

      <span class="button" id="toggle-proofs"></span>

      <span class="right">
	<a href="./">Intro Page</a>
	<a href="./indexpage.html"> Index </a>
	<a href="./search-toc.html"> Full Table of Contents </a>
      </span>
    </div>
    <div id="content" tabindex="-1" onblur="document.getElementById('content').focus()">
      <div id="main">
	<h1>Verification of Spilling Algorithms</h1>
	<p>
	  This is the Coq development accompanying our <!--<a href="todo" class="download">-->submission<!--</a>--> to <a href="http://itp2017.cic.unb.br/">ITP 2017</a>.
	  Coq sources are <a href="lvc-spill.tgz" class="download">available for download</a>.
	  The development is a part of the LVC verified compiler.
	  In <a href="http://www.ps.uni-saarland.de/~sdschn/publications/lvc15/"> previous work,</a> we
	  introduced LVC's intermediate language IL, a first-order language with system calls.
	  IL has two <a href="Lvc.IL.IL.html">semantics</a>, which interpret variables differently, as binders or as <a href="http://www.cs.cmu.edu/~rwh/pfpl.html">assignables</a>.
	  Using a correspondence between the two semantic interpretations, IL in the binder representation realizes term-based static single assignment (SSA).
	</p>
	<p>
	  This development focuses on the verification of spilling in LVC.
	  The implementation of spilling is based on <a href="Lvc.IL.Annotation.html">annotations</a> on the program that indicate at each program point the values of which variables
	  should be spilled and the values of which variables should be loaded.
	  On these annotations, we inductively define a <a href="Lvc.Spilling.SpillSound.html">correctness predicate</a> for spilling.
	  We then show that the predicate is sound, i.e. that every spilling annotation leads to a program that
	  <ul>
	    <li><a href="Lvc.Spilling.RegisterBound.html">meets the register bound</a></li>
	    <li><a href="Lvc.Spilling.VarInRegister.html">keeps values of variables in registers where required by an instruction</a></li>
	    <li><a href="Lvc.Spilling.SpillSim.html">is semantically equivalent to the original program in a certain sense</a></li>
	  </ul>
	  <p>
	    To show a spilling algorithm correct, it now suffices to show that all annotations it produces satisfy the predicate.
	    We verify two spilling algoithms using our predicate.
	    The <a href="Lvc.Spilling.SimpleSpill.html">first algorithm</a> produces a trivial spilling, that maintains the invariant that all values are kept in spill slots.
	    The algorithm inserts the neccessary loads and spills to ensure register availability if required by an instruction.
	    The <a href="Lvc.Spilling.SimpleSpill.html">correctness proof</a> of the algorithm is short.
	    The <a href="Lvc.Spilling.SplitSpill.html">second algorithm</a> is a little bit more clever, and only spills and reloads when required by register pressure,
	    but makes no effort to avoid spilling and reloading inside loops.
	    The decision which variables are overwritten at any given program point is outsourced to an oracle with only trivial correctness requirements
	    and thus any heuristic can be used with little proof effort.
	    The <a href="Lvc.Spilling.SimpleSpill.html">correctness proof</a> is still compact.
	  </p>
	  <p>
	    Finally, we exploit that our correctness predicate is decidable, and give a translation validator.
	    The <a href="Lvc.Spilling.RepairSpill.html">translation validator</a> has a twist: It is able to repair incorrect spilling information in a non-invasive way.
	    We show two theorems about our translation validator.
	    First, that every spilling it produces is <a href="Lvc.Spilling.RepairSpillSound.html">correct</a>.
	    This means that the translation validator is effectively a spilling algorithm.
	    And second, that the translation validator <a href="Lvc.Spilling.RepairSpillIdem.html">does not alter correct spillings</a>.
	    This is the translation validation part of the algorithm.
	    The translation validator tries to remain as faithful as possible to original spilling.
	  </p>
	<h2> Selected Items from the Table of Contents </h2>
	<div class="tocindent">
	  <!--<h3> The Language IL </h3>
	  <div class="toc novfile" id="sectionIL">
	  </div>
	  <h3> Liveness </h3>
	  <div class="toc novfile" id="sectionLiveness">
	  </div>-->
	  <h3> Correctness Predicate </h3>
	  <div class="toc novfile" id="sectionCocri">
          </div>
	  <h3> Generation of the Spilled Program </h3>
	  <div class="toc novfile" id="sectionSpill">
          </div>
	  <h3> Soundness of the Predicate </h3>
	  <div class="toc novfile" id="sectionSound">
          </div>
	  <h3> Spilling Algorithms </h3>
	  <div class="toc novfile" id="sectionAlgo">
          </div>
	  <h3> Translation Validation with Repair </h3>
	  <div class="toc novfile" id="sectionRepair">
          </div>
	</div>
      </div>
    </div>
    <div id="footer">
      Generated by <a href="http://coq.inria.fr/">coqdoc</a> and improved with <a href="https://github.com/tebbi/coqdocjs">CoqdocJS</a>
    </div>
  </body>

</html>
