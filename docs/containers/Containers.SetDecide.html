<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Containers.SetDecide</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Containers.SetDecide</h1>

<div class="code">

<br/>
</div>

<div class="doc">
This file implements a decision procedure for a certain
    class of propositions involving finite sets.  
</div>
<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="Containers.SetInterface.html#"><span class="id" title="library">SetInterface</span></a> <a class="idref" href="Containers.SetFacts.html#"><span class="id" title="library">SetFacts</span></a>.<br/>
<span class="id" title="keyword">Require</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#"><span class="id" title="library">Decidable</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Setoids.Setoid.html#"><span class="id" title="library">Setoid</span></a>.<br/>
<span class="id" title="keyword">Generalizable</span> <span class="id" title="keyword">All</span> <span class="id" title="keyword">Variables</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab41"></a><h1 class="section">Overview</h1>

    This functor defines the tactic <span class="inlinecode"><span class="id" title="var">fsetdec</span></span>, which will
    solve any valid goal of the form
<pre>
    forall s1 ... sn,
    forall x1 ... xm,
    P1 -&gt; ... -&gt; Pk -&gt; P
</pre>
    where <span class="inlinecode"><a class="idref" href="Containers.SetInterface.html#P"><span class="id" title="variable">P</span></a></span>'s are defined by the grammar:
<pre>

P ::=
| Q
| Empty F
| Subset F F'
| Equal F F'

Q ::=
| E.eq X X'
| In X F
| Q /\ Q'
| Q \/ Q'
| Q -&gt; Q'
| Q &lt;-&gt; Q'
| ~ Q
| True
| False

F ::=
| S
| empty
| singleton X
| add X F
| remove X F
| union F F'
| inter F F'
| diff F F'

X ::= x1 | ... | xm
S ::= s1 | ... | sn

</pre>

<div class="paragraph"> </div>

The tactic will also work on some goals that vary slightly from
the above form:
<ul class="doclist">
<li> The variables and hypotheses may be mixed in any order and may
  have already been introduced into the context.  Moreover,
  there may be additional, unrelated hypotheses mixed in (these
  will be ignored).

</li>
<li> A conjunction of hypotheses will be handled as easily as
  separate hypotheses, i.e., <span class="inlinecode"><span class="id" title="var">P1</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" title="var">P2</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="Containers.SetInterface.html#P"><span class="id" title="variable">P</span></a></span> can be solved iff
  <span class="inlinecode"><span class="id" title="var">P1</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">P2</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="Containers.SetInterface.html#P"><span class="id" title="variable">P</span></a></span> can be solved.

</li>
<li> <span class="inlinecode"><span class="id" title="var">fsetdec</span></span> should solve any goal if the FSet-related hypotheses
  are contradictory.

</li>
<li> <span class="inlinecode"><span class="id" title="var">fsetdec</span></span> will first perform any necessary zeta and beta
  reductions and will invoke <span class="inlinecode"><span class="id" title="tactic">subst</span></span> to eliminate any Coq
  equalities between finite sets or their elements.

</li>
<li> If <span class="inlinecode"><span class="id" title="var">E.eq</span></span> is convertible with Coq's equality, it will not
  matter which one is used in the hypotheses or conclusion.

</li>
<li> The tactic can solve goals where the finite sets or set
  elements are expressed by Coq terms that are more complicated
  than variables.  However, non-local definitions are not
  expanded, and Coq equalities between non-variable terms are
  not used.  For example, this goal will be solved:
<pre>
    forall (f : t -&gt; t),
    forall (g : elt -&gt; elt),
    forall (s1 s2 : t),
    forall (x1 x2 : elt),
    Equal s1 (f s2) -&gt;
    E.eq x1 (g (g x2)) -&gt;
    In x1 s1 -&gt;
    In (g (g x2)) (f s2)
</pre>
  This one will not be solved:
<pre>
    forall (f : t -&gt; t),
    forall (g : elt -&gt; elt),
    forall (s1 s2 : t),
    forall (x1 x2 : elt),
    Equal s1 (f s2) -&gt;
    E.eq x1 (g x2) -&gt;
    In x1 s1 -&gt;
    g x2 = g (g x2) -&gt;
    In (g (g x2)) (f s2)
</pre>

</li>
</ul>

<div class="paragraph"> </div>

<a name="lab42"></a><h1 class="section">Facts and Tactics for Propositional Logic</h1>

   These lemmas and tactics are in a module so that they do
   not affect the namespace if you import the enclosing
   module <span class="inlinecode"><span class="id" title="var">Decide</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Module</span> <a name="FSetLogicalFacts"><span class="id" title="module">FSetLogicalFacts</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Export</span> <span class="id" title="var">Decidable</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Export</span> <span class="id" title="var">Setoid</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab43"></a><h2 class="section">Lemmas and Tactics About Decidable Propositions</h2>

<div class="paragraph"> </div>

<a name="lab44"></a><h2 class="section">Propositional Equivalences Involving Negation</h2>

     These are all written with the unfolded form of
     negation, since I am not sure if setoid rewriting will
     always perform conversion. 
<div class="paragraph"> </div>

<a name="lab45"></a><h2 class="section">Tactics for Negations</h2>

</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Tactic Notation</span> "fold" "any" "not" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">fold</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <span class="id" title="var">P</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">fold</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <span class="id" title="var">P</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">push</span></span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#not"><span class="id" title="definition">not</span></a></span> <span class="inlinecode"><span class="id" title="keyword">using</span></span> <span class="inlinecode"><span class="id" title="var">db</span></span> will pushes all negations to the
     leaves of propositions in the goal, using the lemmas in
     <span class="inlinecode"><span class="id" title="var">db</span></span> to assist in checking the decidability of the
     propositions involved.  If <span class="inlinecode"><span class="id" title="keyword">using</span></span> <span class="inlinecode"><span class="id" title="var">db</span></span> is omitted, then
     <span class="inlinecode"><span class="id" title="var">core</span></span> will be used.  Additional versions are provided
     to manipulate the hypotheses or the hypotheses and goal
     together.

<div class="paragraph"> </div>

     XXX: This tactic and the similar subsequent ones should
     have been defined using <span class="inlinecode"><span class="id" title="tactic">autorewrite</span></span>. However, dealing
     with multiples rewrite sites and side-conditions is
     done more cleverly with the following explicit
     analysis of goals. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">or_not_l_iff</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">tac</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#or_not_l_iff_1"><span class="id" title="lemma">or_not_l_iff_1</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">by</span> <span class="id" title="var">tac</span>) ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#or_not_l_iff_2"><span class="id" title="lemma">or_not_l_iff_2</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">by</span> <span class="id" title="var">tac</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">or_not_r_iff</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">tac</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#or_not_r_iff_1"><span class="id" title="lemma">or_not_r_iff_1</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">by</span> <span class="id" title="var">tac</span>) ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#or_not_r_iff_2"><span class="id" title="lemma">or_not_r_iff_2</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">by</span> <span class="id" title="var">tac</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">or_not_l_iff_in</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">H</span> <span class="id" title="var">tac</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#or_not_l_iff_1"><span class="id" title="lemma">or_not_l_iff_1</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span> <span class="id" title="tactic">by</span> <span class="id" title="var">tac</span>) ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#or_not_l_iff_2"><span class="id" title="lemma">or_not_l_iff_2</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span> <span class="id" title="tactic">by</span> <span class="id" title="var">tac</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">or_not_r_iff_in</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">H</span> <span class="id" title="var">tac</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#or_not_r_iff_1"><span class="id" title="lemma">or_not_r_iff_1</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span> <span class="id" title="tactic">by</span> <span class="id" title="var">tac</span>) ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#or_not_r_iff_2"><span class="id" title="lemma">or_not_r_iff_2</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span> <span class="id" title="tactic">by</span> <span class="id" title="var">tac</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Tactic Notation</span> "push" "not" "using" <span class="id" title="var">ident</span>(<span class="id" title="var">db</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">dec</span> := <span class="id" title="var">solve_decidable</span> <span class="id" title="keyword">using</span> <span class="id" title="var">db</span> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#not"><span class="id" title="definition">not</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#iff"><span class="id" title="definition">iff</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] ⇒ <span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_true_iff"><span class="id" title="lemma">not_true_iff</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] ⇒ <span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_false_iff"><span class="id" title="lemma">not_false_iff</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a>?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] ⇒ <span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_not_iff"><span class="id" title="lemma">not_not_iff</span></a> <span class="id" title="var">P</span>) <span class="id" title="tactic">by</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a>?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a>?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a>] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#contrapositive"><span class="id" title="lemma">contrapositive</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">by</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a>?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> ?<span class="id" title="var">Q</span>] ⇒ <span class="id" title="var">or_not_l_iff</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a>?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a>] ⇒ <span class="id" title="var">or_not_r_iff</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a>?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> ?<span class="id" title="var">Q</span>] ⇒ <span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#imp_not_l"><span class="id" title="lemma">imp_not_l</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">by</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> ?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] ⇒ <span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_or_iff"><span class="id" title="lemma">not_or_iff</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> ?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] ⇒ <span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_and_iff"><span class="id" title="lemma">not_and_iff</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a>?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> ?<span class="id" title="var">Q</span><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] ⇒ <span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_imp_iff"><span class="id" title="lemma">not_imp_iff</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">by</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">fold</span> <span class="id" title="var">any</span> <span class="id" title="var">not</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Tactic Notation</span> "push" "not" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">push</span> <span class="id" title="var">not</span> <span class="id" title="keyword">using</span> <span class="id" title="var">core</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Tactic Notation</span><br/>
&nbsp;&nbsp;"push" "not" "in" "*" "|-" "using" <span class="id" title="var">ident</span>(<span class="id" title="var">db</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">dec</span> := <span class="id" title="var">solve_decidable</span> <span class="id" title="keyword">using</span> <span class="id" title="var">db</span> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#not"><span class="id" title="definition">not</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#iff"><span class="id" title="definition">iff</span></a> <span class="id" title="tactic">in</span> × |-;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] |- <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_true_iff"><span class="id" title="lemma">not_true_iff</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] |- <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_false_iff"><span class="id" title="lemma">not_false_iff</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a>?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_not_iff"><span class="id" title="lemma">not_not_iff</span></a> <span class="id" title="var">P</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span> <span class="id" title="tactic">by</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a>?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a>?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a>] |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#contrapositive"><span class="id" title="lemma">contrapositive</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span> <span class="id" title="tactic">by</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a>?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> ?<span class="id" title="var">Q</span>] |- <span class="id" title="var">_</span> ⇒ <span class="id" title="var">or_not_l_iff_in</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">H</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a>?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a>] |- <span class="id" title="var">_</span> ⇒ <span class="id" title="var">or_not_r_iff_in</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">H</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a>?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> ?<span class="id" title="var">Q</span>] |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#imp_not_l"><span class="id" title="lemma">imp_not_l</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span> <span class="id" title="tactic">by</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> ?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] |- <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_or_iff"><span class="id" title="lemma">not_or_iff</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> ?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] |- <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_and_iff"><span class="id" title="lemma">not_and_iff</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a>?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> ?<span class="id" title="var">Q</span><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_imp_iff"><span class="id" title="lemma">not_imp_iff</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span> <span class="id" title="tactic">by</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">fold</span> <span class="id" title="var">any</span> <span class="id" title="var">not</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Tactic Notation</span> "push" "not" "in" "*" "|-"  :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">push</span> <span class="id" title="var">not</span> <span class="id" title="tactic">in</span> × |- <span class="id" title="keyword">using</span> <span class="id" title="var">core</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Tactic Notation</span> "push" "not" "in" "*" "using" <span class="id" title="var">ident</span>(<span class="id" title="var">db</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">push</span> <span class="id" title="var">not</span> <span class="id" title="keyword">using</span> <span class="id" title="var">db</span>; <span class="id" title="var">push</span> <span class="id" title="var">not</span> <span class="id" title="tactic">in</span> × |- <span class="id" title="keyword">using</span> <span class="id" title="var">db</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Tactic Notation</span> "push" "not" "in" "*" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">push</span> <span class="id" title="var">not</span> <span class="id" title="tactic">in</span> × <span class="id" title="keyword">using</span> <span class="id" title="var">core</span>.<br/>

<br/>
</div>

<div class="doc">
A simple test case to see how this works.  
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="FSetLogicalFacts.test_push"><span class="id" title="lemma">test_push</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#decidable"><span class="id" title="definition">decidable</span></a> <a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#decidable"><span class="id" title="definition">decidable</span></a> <a class="idref" href="Containers.SetDecide.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="Containers.SetDecide.html#Q"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="Containers.SetDecide.html#Q"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="Containers.SetDecide.html#Q"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="Containers.SetDecide.html#Q"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">)</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="Containers.SetDecide.html#Q"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetDecide.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">)</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">)</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">)</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">push</span> <span class="id" title="var">not</span> <span class="id" title="tactic">in</span> ×.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">pull</span></span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#not"><span class="id" title="definition">not</span></a></span> <span class="inlinecode"><span class="id" title="keyword">using</span></span> <span class="inlinecode"><span class="id" title="var">db</span></span> will pull as many negations as
     possible toward the top of the propositions in the goal,
     using the lemmas in <span class="inlinecode"><span class="id" title="var">db</span></span> to assist in checking the
     decidability of the propositions involved.  If <span class="inlinecode"><span class="id" title="keyword">using</span></span>
     <span class="inlinecode"><span class="id" title="var">db</span></span> is omitted, then <span class="inlinecode"><span class="id" title="var">core</span></span> will be used.  Additional
     versions are provided to manipulate the hypotheses or
     the hypotheses and goal together. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Tactic Notation</span> "pull" "not" "using" <span class="id" title="var">ident</span>(<span class="id" title="var">db</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">dec</span> := <span class="id" title="var">solve_decidable</span> <span class="id" title="keyword">using</span> <span class="id" title="var">db</span> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#not"><span class="id" title="definition">not</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#iff"><span class="id" title="definition">iff</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] ⇒ <span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_true_iff"><span class="id" title="lemma">not_true_iff</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] ⇒ <span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_false_iff"><span class="id" title="lemma">not_false_iff</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a>?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] ⇒ <span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_not_iff"><span class="id" title="lemma">not_not_iff</span></a> <span class="id" title="var">P</span>) <span class="id" title="tactic">by</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a>?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a>?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a>] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#contrapositive"><span class="id" title="lemma">contrapositive</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">by</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a>?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> ?<span class="id" title="var">Q</span>] ⇒ <span class="id" title="var">or_not_l_iff</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a>?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a>] ⇒ <span class="id" title="var">or_not_r_iff</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a>?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> ?<span class="id" title="var">Q</span>] ⇒ <span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#imp_not_l"><span class="id" title="lemma">imp_not_l</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">by</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">(</span></a>?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">(</span></a>?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">)</span></a>] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_or_iff"><span class="id" title="lemma">not_or_iff</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> ?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] ⇒ <span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_and_iff"><span class="id" title="lemma">not_and_iff</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">(</span></a>?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">)</span></a>] ⇒ <span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_imp_iff"><span class="id" title="lemma">not_imp_iff</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">by</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">(</span></a>?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> ?<span class="id" title="var">P</span>] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_imp_rev_iff"><span class="id" title="lemma">not_imp_rev_iff</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">by</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">fold</span> <span class="id" title="var">any</span> <span class="id" title="var">not</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Tactic Notation</span> "pull" "not" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">pull</span> <span class="id" title="var">not</span> <span class="id" title="keyword">using</span> <span class="id" title="var">core</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Tactic Notation</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;"pull" "not" "in" "*" "|-" "using" <span class="id" title="var">ident</span>(<span class="id" title="var">db</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">dec</span> := <span class="id" title="var">solve_decidable</span> <span class="id" title="keyword">using</span> <span class="id" title="var">db</span> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#not"><span class="id" title="definition">not</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#iff"><span class="id" title="definition">iff</span></a> <span class="id" title="tactic">in</span> × |-;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] |- <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_true_iff"><span class="id" title="lemma">not_true_iff</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] |- <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_false_iff"><span class="id" title="lemma">not_false_iff</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a>?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_not_iff"><span class="id" title="lemma">not_not_iff</span></a> <span class="id" title="var">P</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span> <span class="id" title="tactic">by</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a>?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a>?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a>] |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#contrapositive"><span class="id" title="lemma">contrapositive</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span> <span class="id" title="tactic">by</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a>?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> ?<span class="id" title="var">Q</span>] |- <span class="id" title="var">_</span> ⇒ <span class="id" title="var">or_not_l_iff_in</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">H</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a>?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a>] |- <span class="id" title="var">_</span> ⇒ <span class="id" title="var">or_not_r_iff_in</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">H</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a>?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> ?<span class="id" title="var">Q</span>] |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#imp_not_l"><span class="id" title="lemma">imp_not_l</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span> <span class="id" title="tactic">by</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">(</span></a>?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">(</span></a>?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">)</span></a>] |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_or_iff"><span class="id" title="lemma">not_or_iff</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> ?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>] |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_and_iff"><span class="id" title="lemma">not_and_iff</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">(</span></a>?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">)</span></a>] |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_imp_iff"><span class="id" title="lemma">not_imp_iff</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span> <span class="id" title="tactic">by</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">(</span></a>?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> ?<span class="id" title="var">P</span>] |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#not_imp_rev_iff"><span class="id" title="lemma">not_imp_rev_iff</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span> <span class="id" title="tactic">by</span> <span class="id" title="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">fold</span> <span class="id" title="var">any</span> <span class="id" title="var">not</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Tactic Notation</span> "pull" "not" "in" "*" "|-"  :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">pull</span> <span class="id" title="var">not</span> <span class="id" title="tactic">in</span> × |- <span class="id" title="keyword">using</span> <span class="id" title="var">core</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Tactic Notation</span> "pull" "not" "in" "*" "using" <span class="id" title="var">ident</span>(<span class="id" title="var">db</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">pull</span> <span class="id" title="var">not</span> <span class="id" title="keyword">using</span> <span class="id" title="var">db</span>; <span class="id" title="var">pull</span> <span class="id" title="var">not</span> <span class="id" title="tactic">in</span> × |- <span class="id" title="keyword">using</span> <span class="id" title="var">db</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Tactic Notation</span> "pull" "not" "in" "*" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">pull</span> <span class="id" title="var">not</span> <span class="id" title="tactic">in</span> × <span class="id" title="keyword">using</span> <span class="id" title="var">core</span>.<br/>

<br/>
</div>

<div class="doc">
A simple test case to see how this works.  
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="FSetLogicalFacts.test_pull"><span class="id" title="lemma">test_pull</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#decidable"><span class="id" title="definition">decidable</span></a> <a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#decidable"><span class="id" title="definition">decidable</span></a> <a class="idref" href="Containers.SetDecide.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="Containers.SetDecide.html#Q"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="Containers.SetDecide.html#Q"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="Containers.SetDecide.html#Q"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="Containers.SetDecide.html#Q"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">)</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="Containers.SetDecide.html#Q"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetDecide.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">)</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="Containers.SetDecide.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">pull</span> <span class="id" title="var">not</span> <span class="id" title="tactic">in</span> ×. <span class="id" title="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Containers.SetDecide.html#FSetLogicalFacts"><span class="id" title="module">FSetLogicalFacts</span></a>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">FSetLogicalFacts</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab46"></a><h1 class="section">Auxiliary Tactics</h1>

   Again, these lemmas and tactics are in a module so that
   they do not affect the namespace if you import the
   enclosing module <span class="inlinecode"><span class="id" title="var">Decide</span></span>.  
</div>
<div class="code">
<span class="id" title="keyword">Module</span> <a name="FSetDecideAuxiliary"><span class="id" title="module">FSetDecideAuxiliary</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab47"></a><h2 class="section">Generic Tactics</h2>

   We begin by defining a few generic, useful tactics. 
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="keyword">if</span></span> <span class="inlinecode"><a class="idref" href="Containers.CMapPositive.html#CPositiveMap.t"><span class="id" title="definition">t</span></a></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode"><a class="idref" href="Containers.MapAVL.html#t1"><span class="id" title="variable">t1</span></a></span> <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode"><a class="idref" href="Containers.MapAVL.html#t2"><span class="id" title="variable">t2</span></a></span> executes <span class="inlinecode"><a class="idref" href="Containers.CMapPositive.html#CPositiveMap.t"><span class="id" title="definition">t</span></a></span> and, if it does not
   fail, then <span class="inlinecode"><a class="idref" href="Containers.MapAVL.html#t1"><span class="id" title="variable">t1</span></a></span> will be applied to all subgoals
   produced.  If <span class="inlinecode"><a class="idref" href="Containers.CMapPositive.html#CPositiveMap.t"><span class="id" title="definition">t</span></a></span> fails, then <span class="inlinecode"><a class="idref" href="Containers.MapAVL.html#t2"><span class="id" title="variable">t2</span></a></span> is executed. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Tactic Notation</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;"if" <span class="id" title="var">tactic</span>(<span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"then" <span class="id" title="var">tactic</span>(<span class="id" title="var">t1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"else" <span class="id" title="var">tactic</span>(<span class="id" title="var">t2</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">first</span> [ <span class="id" title="var">t</span>; <span class="id" title="tactic">first</span> [ <span class="id" title="var">t1</span> | <span class="id" title="tactic">fail</span> 2 ] | <span class="id" title="var">t2</span> ].<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">prop</span></span> <span class="inlinecode"><a class="idref" href="Containers.SetInterface.html#P"><span class="id" title="variable">P</span></a></span> <span class="inlinecode"><span class="id" title="var">holds</span></span> <span class="inlinecode"><span class="id" title="tactic">by</span></span> <span class="inlinecode"><a class="idref" href="Containers.CMapPositive.html#CPositiveMap.t"><span class="id" title="definition">t</span></a></span> succeeds (but does not modify the
     goal or context) if the proposition <span class="inlinecode"><a class="idref" href="Containers.SetInterface.html#P"><span class="id" title="variable">P</span></a></span> can be proved by
     <span class="inlinecode"><a class="idref" href="Containers.CMapPositive.html#CPositiveMap.t"><span class="id" title="definition">t</span></a></span> in the current context.  Otherwise, the tactic
     fails. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Tactic Notation</span> "prop" <span class="id" title="keyword">constr</span>(<span class="id" title="var">P</span>) "holds" "by" <span class="id" title="var">tactic</span>(<span class="id" title="var">t</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">H</span> := <span class="id" title="tactic">fresh</span> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> <span class="id" title="var">P</span> <span class="id" title="keyword">as</span> <span class="id" title="var">H</span> <span class="id" title="tactic">by</span> <span class="id" title="var">t</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">clear</span> <span class="id" title="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
This tactic acts just like <span class="inlinecode"><span class="id" title="tactic">assert</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="tactic">by</span></span> <span class="inlinecode">...</span> but will
     fail if the context already contains the proposition. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Tactic Notation</span> "assert" "new" <span class="id" title="keyword">constr</span>(<span class="id" title="var">e</span>) "by" <span class="id" title="var">tactic</span>(<span class="id" title="var">t</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="var">e</span> |- <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">fail</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">assert</span> <span class="id" title="var">e</span> <span class="id" title="tactic">by</span> <span class="id" title="var">t</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="tactic">subst</span>++</span> is similar to <span class="inlinecode"><span class="id" title="tactic">subst</span></span> except that
<ul class="doclist">
<li> it never fails (as <span class="inlinecode"><span class="id" title="tactic">subst</span></span> does on recursive

</li>
</ul>
     equations),
<ul class="doclist">
<li> it substitutes locally defined variable for their

</li>
</ul>
     definitions,
<ul class="doclist">
<li> it performs beta reductions everywhere, which may

</li>
</ul>
     arise after substituting a locally defined function
     for its definition.
     
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Tactic Notation</span> "subst" "++" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> : <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">subst</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">zeta</span> <span class="id" title="keyword">beta</span> <span class="id" title="tactic">in</span> ×.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">decompose</span></span> <span class="inlinecode"><span class="id" title="var">records</span></span> calls <span class="inlinecode"><span class="id" title="var">decompose</span></span> <span class="inlinecode"><span class="id" title="var">record</span></span> <span class="inlinecode"><a class="idref" href="Containers.OrderedType.html#H"><span class="id" title="variable">H</span></a></span> on every
     relevant hypothesis <span class="inlinecode"><a class="idref" href="Containers.OrderedType.html#H"><span class="id" title="variable">H</span></a></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Tactic Notation</span> "decompose" "records" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <a class="idref" href="Containers.SetInterface.html#FSetSpecs"><span class="id" title="class">FSetSpecs</span></a> ?<span class="id" title="var">F</span> |- <span class="id" title="var">_</span> ⇒ <span class="id" title="var">revert</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">progress</span> (<span class="id" title="var">decompose</span> <span class="id" title="var">record</span> <span class="id" title="var">H</span>); <span class="id" title="tactic">clear</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="tactic">intros</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab48"></a><h2 class="section">Discarding Irrelevant Hypotheses</h2>

     We will want to clear the context of any
     non-FSet-related hypotheses in order to increase the
     speed of the tactic.  To do this, we will need to be
     able to decide which are relevant.  We do this by making
     a simple inductive definition classifying the
     propositions of interest. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <a name="FSetDecideAuxiliary.FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> : <span class="id" title="keyword">Prop</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="FSetDecideAuxiliary.eq_Prop"><span class="id" title="constructor">eq_Prop</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">S</span> : <span class="id" title="keyword">Set</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="Containers.SetDecide.html#S"><span class="id" title="variable">S</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> (<a class="idref" href="Containers.SetDecide.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Containers.SetDecide.html#y"><span class="id" title="variable">y</span></a>)<br/>
&nbsp;&nbsp;| <a name="FSetDecideAuxiliary.eq_elt_prop"><span class="id" title="constructor">eq_elt_prop</span></a> : <span class="id" title="keyword">∀</span> `{<a class="idref" href="Containers.OrderedType.html#OrderedType"><span class="id" title="class">OrderedType</span></a> <span class="id" title="var">A</span>} (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="Containers.SetDecide.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> (<a class="idref" href="Containers.SetDecide.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#19766200eef106fd337d8f9453224f75"><span class="id" title="notation">===</span></a> <a class="idref" href="Containers.SetDecide.html#y"><span class="id" title="variable">y</span></a>)<br/>
&nbsp;&nbsp;| <a name="FSetDecideAuxiliary.neq_elt_prop"><span class="id" title="constructor">neq_elt_prop</span></a> : <span class="id" title="keyword">∀</span> `{<a class="idref" href="Containers.OrderedType.html#OrderedType"><span class="id" title="class">OrderedType</span></a> <span class="id" title="var">A</span>} (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="Containers.SetDecide.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> (<a class="idref" href="Containers.SetDecide.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#33471b3c07b8c993b143742ff5232799"><span class="id" title="notation">=/=</span></a> <a class="idref" href="Containers.SetDecide.html#y"><span class="id" title="variable">y</span></a>)<br/>
&nbsp;&nbsp;| <a name="FSetDecideAuxiliary.In_elt_prop"><span class="id" title="constructor">In_elt_prop</span></a> : <span class="id" title="keyword">∀</span> `{<span class="id" title="var">F</span> : @<a class="idref" href="Containers.SetInterface.html#FSet"><span class="id" title="class">FSet</span></a> <span class="id" title="var">A</span> <span class="id" title="var">HA</span>} (<span class="id" title="var">x</span> : <a class="idref" href="Containers.SetDecide.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">s</span> : <a class="idref" href="Containers.SetInterface.html#set"><span class="id" title="method">set</span></a> <a class="idref" href="Containers.SetDecide.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> (<a class="idref" href="Containers.SetInterface.html#In"><span class="id" title="method">In</span></a> <a class="idref" href="Containers.SetDecide.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Containers.SetDecide.html#s"><span class="id" title="variable">s</span></a>)<br/>
&nbsp;&nbsp;| <a name="FSetDecideAuxiliary.True_elt_prop"><span class="id" title="constructor">True_elt_prop</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a><br/>
&nbsp;&nbsp;| <a name="FSetDecideAuxiliary.False_elt_prop"><span class="id" title="constructor">False_elt_prop</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><br/>
&nbsp;&nbsp;| <a name="FSetDecideAuxiliary.conj_elt_prop"><span class="id" title="constructor">conj_elt_prop</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> <a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> <a class="idref" href="Containers.SetDecide.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> (<a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="Containers.SetDecide.html#Q"><span class="id" title="variable">Q</span></a>)<br/>
&nbsp;&nbsp;| <a name="FSetDecideAuxiliary.disj_elt_prop"><span class="id" title="constructor">disj_elt_prop</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> <a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> <a class="idref" href="Containers.SetDecide.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> (<a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="Containers.SetDecide.html#Q"><span class="id" title="variable">Q</span></a>)<br/>
&nbsp;&nbsp;| <a name="FSetDecideAuxiliary.impl_elt_prop"><span class="id" title="constructor">impl_elt_prop</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> <a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> <a class="idref" href="Containers.SetDecide.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> (<a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Containers.SetDecide.html#Q"><span class="id" title="variable">Q</span></a>)<br/>
&nbsp;&nbsp;| <a name="FSetDecideAuxiliary.not_elt_prop"><span class="id" title="constructor">not_elt_prop</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> <a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <a name="FSetDecideAuxiliary.FSet_Prop"><span class="id" title="inductive">FSet_Prop</span></a> : <span class="id" title="keyword">Prop</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="FSetDecideAuxiliary.elt_FSet_Prop"><span class="id" title="constructor">elt_FSet_Prop</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSetDecideAuxiliary.FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> <a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_Prop"><span class="id" title="inductive">FSet_Prop</span></a> <a class="idref" href="Containers.SetDecide.html#P"><span class="id" title="variable">P</span></a><br/>
&nbsp;&nbsp;| <a name="FSetDecideAuxiliary.Empty_FSet_Prop"><span class="id" title="constructor">Empty_FSet_Prop</span></a> : <span class="id" title="keyword">∀</span> `{<span class="id" title="var">F</span> : @<a class="idref" href="Containers.SetInterface.html#FSet"><span class="id" title="class">FSet</span></a> <span class="id" title="var">A</span> <span class="id" title="var">HA</span>} (<span class="id" title="var">s</span> : <a class="idref" href="Containers.SetInterface.html#set"><span class="id" title="method">set</span></a> <a class="idref" href="Containers.SetDecide.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_Prop"><span class="id" title="inductive">FSet_Prop</span></a> (<a class="idref" href="Containers.SetInterface.html#Empty"><span class="id" title="definition">Empty</span></a> <a class="idref" href="Containers.SetDecide.html#s"><span class="id" title="variable">s</span></a>)<br/>
&nbsp;&nbsp;| <a name="FSetDecideAuxiliary.Subset_FSet_Prop"><span class="id" title="constructor">Subset_FSet_Prop</span></a> : <span class="id" title="keyword">∀</span> `{<span class="id" title="var">F</span> : @<a class="idref" href="Containers.SetInterface.html#FSet"><span class="id" title="class">FSet</span></a> <span class="id" title="var">A</span> <span class="id" title="var">HA</span>} (<span class="id" title="var">s1</span> <span class="id" title="var">s2</span> : <a class="idref" href="Containers.SetInterface.html#set"><span class="id" title="method">set</span></a> <a class="idref" href="Containers.SetDecide.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_Prop"><span class="id" title="inductive">FSet_Prop</span></a> (<a class="idref" href="Containers.SetInterface.html#Subset"><span class="id" title="definition">Subset</span></a> <a class="idref" href="Containers.SetDecide.html#s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="Containers.SetDecide.html#s2"><span class="id" title="variable">s2</span></a>)<br/>
&nbsp;&nbsp;| <a name="FSetDecideAuxiliary.Equal_FSet_Prop"><span class="id" title="constructor">Equal_FSet_Prop</span></a> : <span class="id" title="keyword">∀</span> `{<span class="id" title="var">F</span> : @<a class="idref" href="Containers.SetInterface.html#FSet"><span class="id" title="class">FSet</span></a> <span class="id" title="var">A</span> <span class="id" title="var">HA</span>} (<span class="id" title="var">s1</span> <span class="id" title="var">s2</span> : <a class="idref" href="Containers.SetInterface.html#set"><span class="id" title="method">set</span></a> <a class="idref" href="Containers.SetDecide.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Containers.SetDecide.html#FSet_Prop"><span class="id" title="inductive">FSet_Prop</span></a> (<a class="idref" href="Containers.SetInterface.html#Equal"><span class="id" title="definition">Equal</span></a> <a class="idref" href="Containers.SetDecide.html#s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="Containers.SetDecide.html#s2"><span class="id" title="variable">s2</span></a>).<br/>

<br/>
</div>

<div class="doc">
Here is the tactic that will throw away hypotheses that
     are not useful (for the intended scope of the <span class="inlinecode"><span class="id" title="var">fsetdec</span></span>
     tactic). 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Hint Constructors</span> <a class="idref" href="Containers.SetDecide.html#FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> <a class="idref" href="Containers.SetDecide.html#FSet_Prop"><span class="id" title="inductive">FSet_Prop</span></a> : <span class="id" title="var">FSet_Prop</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">discard_nonFSet</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span> : <a class="idref" href="Containers.SetInterface.html#FSetSpecs"><span class="id" title="class">FSetSpecs</span></a> ?<span class="id" title="var">F</span> |- <span class="id" title="var">_</span> ⇒ <span class="id" title="var">revert</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span> : ?<span class="id" title="var">P</span> |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">prop</span> (<a class="idref" href="Containers.SetDecide.html#FSetDecideAuxiliary.FSet_Prop"><span class="id" title="inductive">FSet_Prop</span></a> <span class="id" title="var">P</span>) <span class="id" title="var">holds</span> <span class="id" title="tactic">by</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">auto</span> 100 <span class="id" title="keyword">with</span> <span class="id" title="var">FSet_Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <span class="id" title="tactic">fail</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="tactic">clear</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="tactic">intros</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab49"></a><h2 class="section">Turning Set Operators into Propositional Connectives</h2>

     The lemmas from <span class="inlinecode"><span class="id" title="var">FSetFacts</span></span> will be used to break down
     set operations into propositional formulas built over
     the predicates <span class="inlinecode"><a class="idref" href="Containers.CMapPositive.html#CPositiveMap.In"><span class="id" title="definition">In</span></a></span> and <span class="inlinecode"><span class="id" title="var">E.eq</span></span> applied only to
     variables.  We are going to use them with <span class="inlinecode"><span class="id" title="tactic">autorewrite</span></span>.
     
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Hint Rewrite</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;@<a class="idref" href="Containers.SetFacts.html#empty_iff"><span class="id" title="lemma">empty_iff</span></a> @<a class="idref" href="Containers.SetFacts.html#singleton_iff"><span class="id" title="lemma">singleton_iff</span></a> @<a class="idref" href="Containers.SetFacts.html#add_iff"><span class="id" title="lemma">add_iff</span></a> @<a class="idref" href="Containers.SetFacts.html#remove_iff"><span class="id" title="lemma">remove_iff</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;@<a class="idref" href="Containers.SetFacts.html#union_iff"><span class="id" title="lemma">union_iff</span></a> @<a class="idref" href="Containers.SetFacts.html#inter_iff"><span class="id" title="lemma">inter_iff</span></a> @<a class="idref" href="Containers.SetFacts.html#diff_iff"><span class="id" title="lemma">diff_iff</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">set_simpl</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab50"></a><h2 class="section">Decidability of FSet Propositions</h2>

<div class="paragraph"> </div>

 <span class="inlinecode"><a class="idref" href="Containers.CMapPositive.html#CPositiveMap.In"><span class="id" title="definition">In</span></a></span> is decidable. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="FSetDecideAuxiliary.dec_In"><span class="id" title="lemma">dec_In</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> `{<span class="id" title="var">HF</span> : @<a class="idref" href="Containers.SetInterface.html#FSetSpecs"><span class="id" title="class">FSetSpecs</span></a> <span class="id" title="var">A</span> <span class="id" title="var">HA</span> <span class="id" title="var">F</span>} <span class="id" title="var">x</span> <span class="id" title="var">s</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#decidable"><span class="id" title="definition">decidable</span></a> (<a class="idref" href="Containers.SetInterface.html#In"><span class="id" title="method">In</span></a> <a class="idref" href="Containers.SetDecide.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Containers.SetDecide.html#s"><span class="id" title="variable">s</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">red</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">generalize</span> (<a class="idref" href="Containers.SetFacts.html#mem_iff"><span class="id" title="lemma">mem_iff</span></a> <span class="id" title="var">s</span> <span class="id" title="var">x</span>); <span class="id" title="tactic">case</span> (<a class="idref" href="Containers.SetInterface.html#mem"><span class="id" title="method">mem</span></a> <span class="id" title="var">x</span> <span class="id" title="var">s</span>); <span class="id" title="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">E.eq</span></span> is decidable. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="FSetDecideAuxiliary.dec_eq"><span class="id" title="lemma">dec_eq</span></a> : <span class="id" title="keyword">∀</span> `{<span class="id" title="var">HA</span> : <a class="idref" href="Containers.OrderedType.html#OrderedType"><span class="id" title="class">OrderedType</span></a> <span class="id" title="var">A</span>} (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="Containers.SetDecide.html#A"><span class="id" title="variable">A</span></a>), <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Logic.Decidable.html#decidable"><span class="id" title="definition">decidable</span></a> (<a class="idref" href="Containers.SetDecide.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#19766200eef106fd337d8f9453224f75"><span class="id" title="notation">===</span></a> <a class="idref" href="Containers.SetDecide.html#y"><span class="id" title="variable">y</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">red</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">destruct</span> (<a class="idref" href="Containers.OrderedType.html#eq_dec"><span class="id" title="lemma">eq_dec</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>); <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The hint database <span class="inlinecode"><span class="id" title="var">FSet_decidability</span></span> will be given to
     the <span class="inlinecode"><span class="id" title="var">push_neg</span></span> tactic from the module <span class="inlinecode"><span class="id" title="var">Negation</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Hint Resolve</span> @<a class="idref" href="Containers.SetDecide.html#FSetDecideAuxiliary.dec_In"><span class="id" title="lemma">dec_In</span></a> @<a class="idref" href="Containers.SetDecide.html#FSetDecideAuxiliary.dec_eq"><span class="id" title="lemma">dec_eq</span></a> : <span class="id" title="var">FSet_decidability</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab51"></a><h2 class="section">Normalizing Propositions About Equality</h2>

     We have to deal with the fact that <span class="inlinecode"><span class="id" title="var">E.eq</span></span> may be
     convertible with Coq's equality.  Thus, we will find the
     following tactics useful to replace one form with the
     other everywhere. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">E_neq_to_not_E_eq</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [?<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#33471b3c07b8c993b143742ff5232799"><span class="id" title="notation">=/=</span></a> ?<span class="id" title="var">y</span>] |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">progress</span> (<span class="id" title="tactic">change</span> (<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#33471b3c07b8c993b143742ff5232799"><span class="id" title="notation">=/=</span></a> <span class="id" title="var">y</span>) <span class="id" title="keyword">with</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#19766200eef106fd337d8f9453224f75"><span class="id" title="notation">===</span></a> <span class="id" title="var">y</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [?<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> ?<span class="id" title="var">y</span>] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">progress</span> (<span class="id" title="tactic">change</span> (<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#33471b3c07b8c993b143742ff5232799"><span class="id" title="notation">=/=</span></a> <span class="id" title="var">y</span>) <span class="id" title="keyword">with</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#19766200eef106fd337d8f9453224f75"><span class="id" title="notation">===</span></a> <span class="id" title="var">y</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">Logic_eq_to_E_eq</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [?<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> ?<span class="id" title="var">y</span>] |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">progress</span> (<span class="id" title="tactic">change</span> (<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">y</span>) <span class="id" title="keyword">with</span> (<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#19766200eef106fd337d8f9453224f75"><span class="id" title="notation">===</span></a> <span class="id" title="var">y</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [?<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> ?<span class="id" title="var">y</span>] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">progress</span> (<span class="id" title="tactic">change</span> (<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">y</span>) <span class="id" title="keyword">with</span> (<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#19766200eef106fd337d8f9453224f75"><span class="id" title="notation">===</span></a> <span class="id" title="var">y</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">E_eq_to_Logic_eq</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [?<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#19766200eef106fd337d8f9453224f75"><span class="id" title="notation">===</span></a> ?<span class="id" title="var">y</span>] |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">progress</span> (<span class="id" title="tactic">change</span> (<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#19766200eef106fd337d8f9453224f75"><span class="id" title="notation">===</span></a> <span class="id" title="var">y</span>) <span class="id" title="keyword">with</span> (@<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#eq"><span class="id" title="inductive">Logic.eq</span></a> <span class="id" title="var">_</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [?<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#19766200eef106fd337d8f9453224f75"><span class="id" title="notation">===</span></a> ?<span class="id" title="var">y</span>] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">progress</span> (<span class="id" title="tactic">change</span> (<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#19766200eef106fd337d8f9453224f75"><span class="id" title="notation">===</span></a> <span class="id" title="var">y</span>) <span class="id" title="keyword">with</span> (@<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#eq"><span class="id" title="inductive">Logic.eq</span></a> <span class="id" title="var">_</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>

<br/>
</div>

<div class="doc">
This tactic works like the built-in tactic <span class="inlinecode"><span class="id" title="tactic">subst</span></span>, but
     at the level of set element equality (which may not be
     the convertible with Coq's equality). 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">substFSet</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: ?<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#19766200eef106fd337d8f9453224f75"><span class="id" title="notation">===</span></a> ?<span class="id" title="var">y</span> |- <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span> <span class="id" title="tactic">in</span> *; <span class="id" title="tactic">clear</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab52"></a><h2 class="section">Considering Decidability of Base Propositions</h2>

     This tactic adds assertions about the decidability of
     <span class="inlinecode"><span class="id" title="var">E.eq</span></span> and <span class="inlinecode"><a class="idref" href="Containers.CMapPositive.html#CPositiveMap.In"><span class="id" title="definition">In</span></a></span> to the context.  This is necessary for
     the completeness of the <span class="inlinecode"><span class="id" title="var">fsetdec</span></span> tactic.  However, in
     order to minimize the cost of proof search, we should be
     careful to not add more than we need.  Once negations
     have been pushed to the leaves of the propositions, we
     only need to worry about decidability for those base
     propositions that appear in a negated form. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">assert_decidability</span> :=<br/>
&nbsp;&nbsp;</div>

<div class="doc">
We actually don't want these rules to fire if the
     syntactic context in the patterns below is trivially
     empty, but we'll just do some clean-up at the
     afterward.  
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [?<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#33471b3c07b8c993b143742ff5232799"><span class="id" title="notation">=/=</span></a> ?<span class="id" title="var">y</span>] |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> <span class="id" title="var">new</span> (<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#19766200eef106fd337d8f9453224f75"><span class="id" title="notation">===</span></a> <span class="id" title="var">y</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#33471b3c07b8c993b143742ff5232799"><span class="id" title="notation">=/=</span></a> <span class="id" title="var">y</span>) <span class="id" title="tactic">by</span> (<span class="id" title="tactic">apply</span> <a class="idref" href="Containers.SetDecide.html#FSetDecideAuxiliary.dec_eq"><span class="id" title="lemma">dec_eq</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="Containers.SetInterface.html#In"><span class="id" title="method">In</span></a> ?<span class="id" title="var">x</span> ?<span class="id" title="var">s</span>] |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> <span class="id" title="var">new</span> (<a class="idref" href="Containers.SetInterface.html#In"><span class="id" title="method">In</span></a> <span class="id" title="var">x</span> <span class="id" title="var">s</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="Containers.SetInterface.html#In"><span class="id" title="method">In</span></a> <span class="id" title="var">x</span> <span class="id" title="var">s</span>) <span class="id" title="tactic">by</span> (<span class="id" title="tactic">apply</span> <a class="idref" href="Containers.SetDecide.html#FSetDecideAuxiliary.dec_In"><span class="id" title="lemma">dec_In</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [?<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#33471b3c07b8c993b143742ff5232799"><span class="id" title="notation">=/=</span></a> ?<span class="id" title="var">y</span>] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> <span class="id" title="var">new</span> (<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#19766200eef106fd337d8f9453224f75"><span class="id" title="notation">===</span></a> <span class="id" title="var">y</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#33471b3c07b8c993b143742ff5232799"><span class="id" title="notation">=/=</span></a> <span class="id" title="var">y</span>) <span class="id" title="tactic">by</span> (<span class="id" title="tactic">apply</span> <a class="idref" href="Containers.SetDecide.html#FSetDecideAuxiliary.dec_eq"><span class="id" title="lemma">dec_eq</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">context</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="Containers.SetInterface.html#In"><span class="id" title="method">In</span></a> ?<span class="id" title="var">x</span> ?<span class="id" title="var">s</span>] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> <span class="id" title="var">new</span> (<a class="idref" href="Containers.SetInterface.html#In"><span class="id" title="method">In</span></a> <span class="id" title="var">x</span> <span class="id" title="var">s</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="Containers.SetInterface.html#In"><span class="id" title="method">In</span></a> <span class="id" title="var">x</span> <span class="id" title="var">s</span>) <span class="id" title="tactic">by</span> (<span class="id" title="tactic">apply</span> <a class="idref" href="Containers.SetDecide.html#FSetDecideAuxiliary.dec_In"><span class="id" title="lemma">dec_In</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>);<br/>
&nbsp;&nbsp;</div>

<div class="doc">
Now we eliminate the useless facts we added (because
     they would likely be very harmful to performance). 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> ?<span class="id" title="var">P</span>, <span class="id" title="var">H</span> : ?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> ?<span class="id" title="var">P</span> |- <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">clear</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab53"></a><h2 class="section">Handling <span class="inlinecode"><a class="idref" href="Containers.CMapPositive.html#CPositiveMap.Empty"><span class="id" title="definition">Empty</span></a></span>, <span class="inlinecode"><a class="idref" href="Containers.SetAVL.html#Subset"><span class="id" title="definition">Subset</span></a></span>, and <span class="inlinecode"><a class="idref" href="Containers.CMapPositive.html#CPositiveMap.Equal"><span class="id" title="definition">Equal</span></a></span></h2>

     This tactic instantiates universally quantified
     hypotheses (which arise from the unfolding of <span class="inlinecode"><a class="idref" href="Containers.CMapPositive.html#CPositiveMap.Empty"><span class="id" title="definition">Empty</span></a></span>,
     <span class="inlinecode"><a class="idref" href="Containers.SetAVL.html#Subset"><span class="id" title="definition">Subset</span></a></span>, and <span class="inlinecode"><a class="idref" href="Containers.CMapPositive.html#CPositiveMap.Equal"><span class="id" title="definition">Equal</span></a></span>) for each of the set element
     expressions that is involved in some membership or
     equality fact.  Then it throws away those hypotheses,
     which should no longer be needed. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Notation</span> <a name="FSetDecideAuxiliary.Eq"><span class="id" title="abbreviation">Eq</span></a> := @<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#equiv"><span class="id" title="definition">Equivalence.equiv</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">inst_FSet_hypotheses</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : ?<span class="id" title="var">A</span>, <span class="id" title="var">_</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span> : <span class="id" title="keyword">context</span> [ @<a class="idref" href="Containers.SetInterface.html#In"><span class="id" title="method">In</span></a> ?<span class="id" title="var">A</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ?<span class="id" title="var">x</span> <span class="id" title="var">_</span> ] |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">P</span> := <span class="id" title="keyword">type</span> <span class="id" title="keyword">of</span> (<span class="id" title="var">H</span> <span class="id" title="var">x</span>) <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> <span class="id" title="var">new</span> <span class="id" title="var">P</span> <span class="id" title="tactic">by</span> (<span class="id" title="tactic">exact</span> (<span class="id" title="var">H</span> <span class="id" title="var">x</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : ?<span class="id" title="var">A</span>, <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- <span class="id" title="keyword">context</span> [ @<a class="idref" href="Containers.SetInterface.html#In"><span class="id" title="method">In</span></a> ?<span class="id" title="var">A</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ?<span class="id" title="var">x</span> <span class="id" title="var">_</span> ] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">P</span> := <span class="id" title="keyword">type</span> <span class="id" title="keyword">of</span> (<span class="id" title="var">H</span> <span class="id" title="var">x</span>) <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> <span class="id" title="var">new</span> <span class="id" title="var">P</span> <span class="id" title="tactic">by</span> (<span class="id" title="tactic">exact</span> (<span class="id" title="var">H</span> <span class="id" title="var">x</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : ?<span class="id" title="var">A</span>, <span class="id" title="var">_</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span> : <span class="id" title="keyword">context</span> [@<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#equiv"><span class="id" title="definition">Equivalence.equiv</span></a> ?<span class="id" title="var">A</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ?<span class="id" title="var">x</span> ?<span class="id" title="var">y</span> ] |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">P</span> := <span class="id" title="keyword">type</span> <span class="id" title="keyword">of</span> (<span class="id" title="var">H</span> <span class="id" title="var">x</span>) <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">P'</span> := <span class="id" title="keyword">type</span> <span class="id" title="keyword">of</span> (<span class="id" title="var">H</span> <span class="id" title="var">y</span>) <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> <span class="id" title="var">new</span> <span class="id" title="var">P</span> <span class="id" title="tactic">by</span> (<span class="id" title="tactic">exact</span> (<span class="id" title="var">H</span> <span class="id" title="var">x</span>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> <span class="id" title="var">new</span> <span class="id" title="var">P'</span> <span class="id" title="tactic">by</span> (<span class="id" title="tactic">exact</span> (<span class="id" title="var">H</span> <span class="id" title="var">y</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : ?<span class="id" title="var">A</span>, <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- <span class="id" title="keyword">context</span> [@<a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#equiv"><span class="id" title="definition">Equivalence.equiv</span></a> ?<span class="id" title="var">A</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ?<span class="id" title="var">x</span> ?<span class="id" title="var">y</span> ] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">P</span> := <span class="id" title="keyword">type</span> <span class="id" title="keyword">of</span> (<span class="id" title="var">H</span> <span class="id" title="var">x</span>) <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">P'</span> := <span class="id" title="keyword">type</span> <span class="id" title="keyword">of</span> (<span class="id" title="var">H</span> <span class="id" title="var">y</span>) <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> <span class="id" title="var">new</span> <span class="id" title="var">P</span> <span class="id" title="tactic">by</span> (<span class="id" title="tactic">exact</span> (<span class="id" title="var">H</span> <span class="id" title="var">x</span>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> <span class="id" title="var">new</span> <span class="id" title="var">P'</span> <span class="id" title="tactic">by</span> (<span class="id" title="tactic">exact</span> (<span class="id" title="var">H</span> <span class="id" title="var">y</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : ?<span class="id" title="var">A</span>, <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">type</span> <span class="id" title="keyword">of</span> <span class="id" title="var">A</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">Prop</span> ⇒ <span class="id" title="var">revert</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">clear</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="tactic">intros</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab54"></a><h2 class="section">The Core <span class="inlinecode"><span class="id" title="var">fsetdec</span></span> Auxiliary Tactics</h2>

<div class="paragraph"> </div>

 Here is the crux of the proof search.  Recursion through
     <span class="inlinecode"><span class="id" title="tactic">intuition</span></span>!  (This will terminate if I correctly
     understand the behavior of <span class="inlinecode"><span class="id" title="tactic">intuition</span></span>.) 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">fsetdec_rec</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">try</span> (<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: ?<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#19766200eef106fd337d8f9453224f75"><span class="id" title="notation">===</span></a> ?<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> |- <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">reflexivity</span> ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">contradiction</span> ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">progress</span> <span class="id" title="var">substFSet</span>; <span class="id" title="tactic">intuition</span> <span class="id" title="var">fsetdec_rec</span>)).<br/>

<br/>
</div>

<div class="doc">
If we add <span class="inlinecode"><span class="id" title="tactic">unfold</span></span> <span class="inlinecode"><a class="idref" href="Containers.CMapPositive.html#CPositiveMap.Empty"><span class="id" title="definition">Empty</span></a>,</span> <span class="inlinecode"><a class="idref" href="Containers.SetAVL.html#Subset"><span class="id" title="definition">Subset</span></a>,</span> <span class="inlinecode"><a class="idref" href="Containers.CMapPositive.html#CPositiveMap.Equal"><span class="id" title="definition">Equal</span></a></span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode">*;</span> <span class="inlinecode"><span class="id" title="tactic">intros</span>;</span> to
     the beginning of this tactic, it will satisfy the same
     specification as the <span class="inlinecode"><span class="id" title="var">fsetdec</span></span> tactic; however, it will
     be much slower than necessary without the pre-processing
     done by the wrapper tactic <span class="inlinecode"><span class="id" title="var">fsetdec</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">fsetdec_body</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inst_FSet_hypotheses</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">set_simpl</span> <span class="id" title="tactic">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">push</span> <span class="id" title="var">not</span> <span class="id" title="tactic">in</span> × <span class="id" title="keyword">using</span> <span class="id" title="var">FSet_decidability</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">substFSet</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">assert_decidability</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span> <span class="id" title="keyword">using</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.RelationClasses.html#reflexivity"><span class="id" title="definition">reflexivity</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">intuition</span> <span class="id" title="var">fsetdec_rec</span>) ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">fail</span> 1 "because the goal is beyond the scope of this tactic".<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Containers.SetDecide.html#FSetDecideAuxiliary"><span class="id" title="module">FSetDecideAuxiliary</span></a>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">FSetDecideAuxiliary</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab55"></a><h1 class="section">The <span class="inlinecode"><span class="id" title="var">fsetdec</span></span> Tactic</h1>

   Here is the top-level tactic (the only one intended for
   clients of this library).  It's specification is given at
   the top of the file. 
</div>
<div class="code">
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">fsetdec</span> :=<br/>
</div>

<div class="doc">
We first unfold any occurrences of <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#iff"><span class="id" title="definition">iff</span></a></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#iff"><span class="id" title="definition">iff</span></a> <span class="id" title="tactic">in</span> *;<br/>
</div>

<div class="doc">
We fold occurrences of <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#not"><span class="id" title="definition">not</span></a></span> because it is better for
   <span class="inlinecode"><span class="id" title="tactic">intros</span></span> to leave us with a goal of <span class="inlinecode">¬</span> <span class="inlinecode"><a class="idref" href="Containers.SetInterface.html#P"><span class="id" title="variable">P</span></a></span> than a goal of
   <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">fold</span> <span class="id" title="var">any</span> <span class="id" title="var">not</span>; <span class="id" title="tactic">intros</span>;<br/>
</div>

<div class="doc">
Now we decompose conjunctions, which will allow the
   <span class="inlinecode"><span class="id" title="var">discard_nonFSet</span></span> and <span class="inlinecode"><span class="id" title="var">assert_decidability</span></span> tactics to
   do a much better job. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">decompose</span> <span class="id" title="var">records</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">discard_nonFSet</span>;<br/>
</div>

<div class="doc">
We unfold these defined propositions on finite sets.  If
   our goal was one of them, then have one more item to
   introduce now. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Containers.SetInterface.html#Empty"><span class="id" title="definition">Empty</span></a>, <a class="idref" href="Containers.SetInterface.html#Subset"><span class="id" title="definition">Subset</span></a>, <a class="idref" href="Containers.SetInterface.html#Equal"><span class="id" title="definition">Equal</span></a> <span class="id" title="tactic">in</span> *; <span class="id" title="tactic">intros</span>;<br/>
</div>

<div class="doc">
We now want to get rid of all uses of <span class="inlinecode">=</span> in favor of
   <span class="inlinecode"><span class="id" title="var">E.eq</span></span>.  However, the best way to eliminate a <span class="inlinecode">=</span> is in
   the context is with <span class="inlinecode"><span class="id" title="tactic">subst</span></span>, so we will try that first.
   In fact, we may as well convert uses of <span class="inlinecode"><span class="id" title="var">E.eq</span></span> into <span class="inlinecode">=</span>
   when possible before we do <span class="inlinecode"><span class="id" title="tactic">subst</span></span> so that we can even
   more mileage out of it.  Then we will convert all
   remaining uses of <span class="inlinecode">=</span> back to <span class="inlinecode"><span class="id" title="var">E.eq</span></span> when possible.  We
   use <span class="inlinecode"><span class="id" title="var">change_to_E_t</span></span> to ensure that we have a canonical
   name for set elements, so that <span class="inlinecode"><span class="id" title="var">Logic_eq_to_E_eq</span></span> will
   work properly.  
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">E_eq_to_Logic_eq</span>; <span class="id" title="tactic">subst</span>++;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">E_neq_to_not_E_eq</span>; <span class="id" title="var">Logic_eq_to_E_eq</span>;<br/>
</div>

<div class="doc">
The next optimization is to swap a negated goal with a
   negated hypothesis when possible.  Any swap will improve
   performance by eliminating the total number of
   negations, but we will get the maximum benefit if we
   swap the goal with a hypotheses mentioning the same set
   element, so we try that first.  If we reach the fourth
   branch below, we attempt any swap.  However, to maintain
   completeness of this tactic, we can only perform such a
   swap with a decidable proposition; hence, we first test
   whether the hypothesis is an <span class="inlinecode"><a class="idref" href="Containers.SetDecide.html#FSetDecideAuxiliary.FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a></span>, noting
   that any <span class="inlinecode"><a class="idref" href="Containers.SetDecide.html#FSetDecideAuxiliary.FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a></span> is decidable. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">pull</span> <span class="id" title="var">not</span> <span class="id" title="keyword">using</span> <span class="id" title="var">FSet_decidability</span>;<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#not"><span class="id" title="definition">not</span></a> <span class="id" title="tactic">in</span> *;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetInterface.html#In"><span class="id" title="method">In</span></a> ?<span class="id" title="var">x</span> ?<span class="id" title="var">r</span><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> |- <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetInterface.html#In"><span class="id" title="method">In</span></a> ?<span class="id" title="var">x</span> ?<span class="id" title="var">s</span><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">contradict</span> <span class="id" title="var">H</span>; <span class="id" title="var">fsetdec_body</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetInterface.html#In"><span class="id" title="method">In</span></a> ?<span class="id" title="var">x</span> ?<span class="id" title="var">r</span><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> |- <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a>?<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#19766200eef106fd337d8f9453224f75"><span class="id" title="notation">===</span></a> ?<span class="id" title="var">y</span><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">contradict</span> <span class="id" title="var">H</span>; <span class="id" title="var">fsetdec_body</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="Containers.SetInterface.html#In"><span class="id" title="method">In</span></a> ?<span class="id" title="var">x</span> ?<span class="id" title="var">r</span><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> |- <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a>?<span class="id" title="var">y</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Classes.Equivalence.html#19766200eef106fd337d8f9453224f75"><span class="id" title="notation">===</span></a> ?<span class="id" title="var">x</span><a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">contradict</span> <span class="id" title="var">H</span>; <span class="id" title="var">fsetdec_body</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">H</span>: ?<span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> |- ?<span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">prop</span> (<a class="idref" href="Containers.SetDecide.html#FSet_elt_Prop"><span class="id" title="inductive">FSet_elt_Prop</span></a> <span class="id" title="var">P</span>) <span class="id" title="var">holds</span> <span class="id" title="tactic">by</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">auto</span> 100 <span class="id" title="keyword">with</span> <span class="id" title="var">FSet_Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> (<span class="id" title="var">contradict</span> <span class="id" title="var">H</span>; <span class="id" title="var">fsetdec_body</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="var">fsetdec_body</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">fsetdec_body</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="indexpage.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>